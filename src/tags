!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
A	math3d.cpp	129;"	d	file:
A	math3d.cpp	157;"	d	file:
A33	math3d.cpp	162;"	d	file:
A33	math3d.cpp	189;"	d	file:
ANTI_CLOCK_WISE_ROTATION	_object_base.hpp	/^			CLOCK_WISE_ROTATION, ANTI_CLOCK_WISE_ROTATION, Z_TURN_STOP };$/;"	e	enum:MOTION_STATE
ATTRIBUTE_INDEX_COLOR	AttributeIndex.hpp	/^			ATTRIBUTE_INDEX_COLOR,$/;"	e	enum:SHADER_ATTRIBUTE
ATTRIBUTE_INDEX_LAST	AttributeIndex.hpp	/^			ATTRIBUTE_INDEX_LAST$/;"	e	enum:SHADER_ATTRIBUTE
ATTRIBUTE_INDEX_NORMAL	AttributeIndex.hpp	/^			ATTRIBUTE_INDEX_NORMAL,$/;"	e	enum:SHADER_ATTRIBUTE
ATTRIBUTE_INDEX_TEXTURE0	AttributeIndex.hpp	/^			ATTRIBUTE_INDEX_TEXTURE0,$/;"	e	enum:SHADER_ATTRIBUTE
ATTRIBUTE_INDEX_TEXTURE1	AttributeIndex.hpp	/^			ATTRIBUTE_INDEX_TEXTURE1,$/;"	e	enum:SHADER_ATTRIBUTE
ATTRIBUTE_INDEX_TEXTURE2	AttributeIndex.hpp	/^			ATTRIBUTE_INDEX_TEXTURE2,$/;"	e	enum:SHADER_ATTRIBUTE
ATTRIBUTE_INDEX_TEXTURE3	AttributeIndex.hpp	/^			ATTRIBUTE_INDEX_TEXTURE3,$/;"	e	enum:SHADER_ATTRIBUTE
ATTRIBUTE_INDEX_VERTEX	AttributeIndex.hpp	/^enum SHADER_ATTRIBUTE {	ATTRIBUTE_INDEX_VERTEX= 0,$/;"	e	enum:SHADER_ATTRIBUTE
B	math3d.cpp	130;"	d	file:
B	math3d.cpp	158;"	d	file:
B33	math3d.cpp	163;"	d	file:
B33	math3d.cpp	190;"	d	file:
BACK	_model_manager.hpp	/^enum CUBE_SIDE{ FRONT = 1, BACK, LEFT, RIGHT, UP, BOTTOM };$/;"	e	enum:CUBE_SIDE
BACKWARD	_object_base.hpp	/^			FORWORD, BACKWARD, Z_MOVE_STOP,$/;"	e	enum:MOTION_STATE
BOTTOM	_model_manager.hpp	/^enum CUBE_SIDE{ FRONT = 1, BACK, LEFT, RIGHT, UP, BOTTOM };$/;"	e	enum:CUBE_SIDE
CHANGE	_shader_manager.cpp	24;"	d	file:
CHANGE	_shader_manager.cpp	38;"	d	file:
CLOCK_WISE_ROTATION	_object_base.hpp	/^			CLOCK_WISE_ROTATION, ANTI_CLOCK_WISE_ROTATION, Z_TURN_STOP };$/;"	e	enum:MOTION_STATE
CUBE_SIDE	_model_manager.hpp	/^enum CUBE_SIDE{ FRONT = 1, BACK, LEFT, RIGHT, UP, BOTTOM };$/;"	g
CreateProgram	ShaderManage.cpp	/^GLuint ShaderManage::CreateProgram(const std::vector<GLuint> &shaderList, const std::vector<GLuint> attributeNum)$/;"	f	class:ShaderManage
CreateShader	ShaderManage.hpp	/^	inline GLuint CreateShader(GLenum eShaderType, const std::string &strShaderFile)$/;"	f	class:ShaderManage
CreateVFShaderProgram	ShaderManage.hpp	/^	inline GLuint CreateVFShaderProgram(const std::string &strVertexFile, const std::string &strFragmentFile, const std::vector<GLuint> attributeNum)$/;"	f	class:ShaderManage
DAE	_asset_manager.hpp	/^enum FILE_FORMAT { DAE = 1 };$/;"	e	enum:FILE_FORMAT
DOWN_ROTATION	_object_base.hpp	/^			UP_ROTATION, DOWN_ROTATION, X_TURN_STOP,$/;"	e	enum:MOTION_STATE
DOWN_WARD	_object_base.hpp	/^			UP_WARD, DOWN_WARD, Y_MOVE_STOP,$/;"	e	enum:MOTION_STATE
DetIJ	math3d.cpp	/^static double DetIJ(const M3DMatrix44d m, const int i, const int j)$/;"	f	file:
DetIJ	math3d.cpp	/^static float DetIJ(const M3DMatrix44f m, const int i, const int j)$/;"	f	file:
FILE_FORMAT	_asset_manager.hpp	/^enum FILE_FORMAT { DAE = 1 };$/;"	g
FORWORD	_object_base.hpp	/^			FORWORD, BACKWARD, Z_MOVE_STOP,$/;"	e	enum:MOTION_STATE
FRONT	_model_manager.hpp	/^enum CUBE_SIDE{ FRONT = 1, BACK, LEFT, RIGHT, UP, BOTTOM };$/;"	e	enum:CUBE_SIDE
FindFileOrThrow	ShaderManage.hpp	/^	std::string FindFileOrThrow( const std::string &strBasename)$/;"	f	class:ShaderManage
GetShader	ShaderManage.hpp	/^	inline void GetShader(GLenum eShaderType, const std::string &strVertexFile)$/;"	f	class:ShaderManage
GetShader	ShaderManage.hpp	/^	inline void GetShader(GLenum eShaderType1, GLenum eShaderType2,const std::string &strVertexFile, const std::string &strFragmentFile)$/;"	f	class:ShaderManage
HDRS	Makefile	/^HDRS =$/;"	m
LEFT	_model_manager.hpp	/^enum CUBE_SIDE{ FRONT = 1, BACK, LEFT, RIGHT, UP, BOTTOM };$/;"	e	enum:CUBE_SIDE
LEFT_ROTATION	_object_base.hpp	/^			LEFT_ROTATION, RIGHT_ROTATION, Y_TURN_STOP,$/;"	e	enum:MOTION_STATE
LEFT_WARD	_object_base.hpp	/^			RIGHT_WARD, LEFT_WARD, X_MOVE_STOP,$/;"	e	enum:MOTION_STATE
LIGHT_SOURCE_SHADER	_scene_base.hpp	/^enum {NORMAL_SHADER, LIGHT_SOURCE_SHADER};$/;"	e	enum:__anon1
LS	Makefile	/^LS = -I\/usr\/local\/include\/bullet\/ -lSDL2 -lassimp -Wl,-rpath=\/usr\/local\/lib  -lGLEW \\$/;"	m
M	math3d.cpp	308;"	d	file:
M	math3d.cpp	341;"	d	file:
M	math3d.cpp	369;"	d	file:
M	math3d.cpp	394;"	d	file:
M	math3d.cpp	421;"	d	file:
M	math3d.cpp	454;"	d	file:
M33	math3d.cpp	234;"	d	file:
M33	math3d.cpp	283;"	d	file:
M3DMatrix33d	math3d.h	/^typedef double	M3DMatrix33d[9];		\/\/ A 3 x 3 matrix, column major (doubles) - OpenGL Style$/;"	t
M3DMatrix33f	math3d.h	/^typedef float	M3DMatrix33f[9];		\/\/ A 3 x 3 matrix, column major (floats) - OpenGL Style$/;"	t
M3DMatrix44d	math3d.h	/^typedef double M3DMatrix44d[16];	\/\/ A 4 x 4 matrix, column major (doubles) - OpenGL style$/;"	t
M3DMatrix44f	math3d.h	/^typedef float M3DMatrix44f[16];		\/\/ A 4 X 4 matrix, column major (floats) - OpenGL style$/;"	t
M3DVector2d	math3d.h	/^typedef double	M3DVector2d[2];		\/\/ 2D representations sometimes... (x,y) order$/;"	t
M3DVector2f	math3d.h	/^typedef float	M3DVector2f[2];		\/\/ 3D points = 3D Vectors, but we need a $/;"	t
M3DVector3d	math3d.h	/^typedef double	M3DVector3d[3];		\/\/ Vector of three doubles (x, y, z)$/;"	t
M3DVector3f	math3d.h	/^typedef float	M3DVector3f[3];		\/\/ Vector of three floats (x, y, z)$/;"	t
M3DVector4d	math3d.h	/^typedef double	M3DVector4d[4];		\/\/ Yes, occasionaly we do need a trailing w component$/;"	t
M3DVector4f	math3d.h	/^typedef float	M3DVector4f[4];		\/\/ Lesser used... Do we really need these?$/;"	t
M3D_2PI	math3d.h	90;"	d
M3D_INV_PI_DIV_180	math3d.h	92;"	d
M3D_PI	math3d.h	89;"	d
M3D_PI_DIV_180	math3d.h	91;"	d
MOTION_STATE	_object_base.hpp	/^enum MOTION_STATE {	NO_MOSTION = 0,$/;"	g
NORMAL_SHADER	_scene_base.hpp	/^enum {NORMAL_SHADER, LIGHT_SOURCE_SHADER};$/;"	e	enum:__anon1
NO_MOSTION	_object_base.hpp	/^enum MOTION_STATE {	NO_MOSTION = 0,$/;"	e	enum:MOTION_STATE
OBJS	Makefile	/^OBJS = fulcrum.o math3d.o ShaderManage.o _scene_base.o _object_base.o _light_base.o \\$/;"	m
P	math3d.cpp	131;"	d	file:
P	math3d.cpp	159;"	d	file:
P33	math3d.cpp	164;"	d	file:
P33	math3d.cpp	191;"	d	file:
RIGHT	_model_manager.hpp	/^enum CUBE_SIDE{ FRONT = 1, BACK, LEFT, RIGHT, UP, BOTTOM };$/;"	e	enum:CUBE_SIDE
RIGHT_ROTATION	_object_base.hpp	/^			LEFT_ROTATION, RIGHT_ROTATION, Y_TURN_STOP,$/;"	e	enum:MOTION_STATE
RIGHT_WARD	_object_base.hpp	/^			RIGHT_WARD, LEFT_WARD, X_MOVE_STOP,$/;"	e	enum:MOTION_STATE
SCREEN_HEIGHT	fulcrum.cpp	/^const int SCREEN_HEIGHT = 768;$/;"	v
SCREEN_WIDTH	fulcrum.cpp	/^const int SCREEN_WIDTH = 1366;$/;"	v
SCRS	Makefile	/^SCRS =$/;"	m
SHADER_ATTRIBUTE	AttributeIndex.hpp	/^enum SHADER_ATTRIBUTE {	ATTRIBUTE_INDEX_VERTEX= 0,$/;"	g
ShaderManage	ShaderManage.cpp	/^ShaderManage::ShaderManage()$/;"	f	class:ShaderManage
ShaderManage	ShaderManage.hpp	/^class ShaderManage {$/;"	c
UP	_model_manager.hpp	/^enum CUBE_SIDE{ FRONT = 1, BACK, LEFT, RIGHT, UP, BOTTOM };$/;"	e	enum:CUBE_SIDE
UP_ROTATION	_object_base.hpp	/^			UP_ROTATION, DOWN_ROTATION, X_TURN_STOP,$/;"	e	enum:MOTION_STATE
UP_WARD	_object_base.hpp	/^			UP_WARD, DOWN_WARD, Y_MOVE_STOP,$/;"	e	enum:MOTION_STATE
X_MOVE_STOP	_object_base.hpp	/^			RIGHT_WARD, LEFT_WARD, X_MOVE_STOP,$/;"	e	enum:MOTION_STATE
X_TURN_STOP	_object_base.hpp	/^			UP_ROTATION, DOWN_ROTATION, X_TURN_STOP,$/;"	e	enum:MOTION_STATE
Y_MOVE_STOP	_object_base.hpp	/^			UP_WARD, DOWN_WARD, Y_MOVE_STOP,$/;"	e	enum:MOTION_STATE
Y_TURN_STOP	_object_base.hpp	/^			LEFT_ROTATION, RIGHT_ROTATION, Y_TURN_STOP,$/;"	e	enum:MOTION_STATE
Z_MOVE_STOP	_object_base.hpp	/^			FORWORD, BACKWARD, Z_MOVE_STOP,$/;"	e	enum:MOTION_STATE
Z_TURN_STOP	_object_base.hpp	/^			CLOCK_WISE_ROTATION, ANTI_CLOCK_WISE_ROTATION, Z_TURN_STOP };$/;"	e	enum:MOTION_STATE
_ASSET_MANAGER_HPP_	_asset_manager.hpp	2;"	d
_CAMERA_BASE_HPP_	_camera_base.hpp	2;"	d
_CONTROLLER_BASE_HPP_	_controller_base.hpp	2;"	d
_ID	_object_base.hpp	/^	int _ID;$/;"	m	class:_object_base
_LIGHT_BASE_HPP_	_light_base.hpp	2;"	d
_LIGHT_BASE_SET_HPP_	_light_base_set.hpp	2;"	d
_MATH3D_LIBRARY__	math3d.h	42;"	d
_MODEL_MANAGER_HPP_	_model_manager.hpp	2;"	d
_OBJECT_BASE_HPP_	_object_base.hpp	2;"	d
_SCENE_BASE_HPP_	_scene_base.hpp	2;"	d
_SHADER_MANAGER_HPP_	_shader_manager.hpp	2;"	d
_SHADER_MANAGE_HPP_	ShaderManage.hpp	2;"	d
_ambient_color	_light_base.hpp	/^	_ambient_color,$/;"	m	class:_light_base
_ambient_color_in_scene	_scene_base.hpp	/^	glm::vec4 _ambient_color_in_scene;$/;"	m	class:_scene_base
_angular	_object_base.hpp	/^	btVector3 _angular;$/;"	m	class:_object_base
_angular_x	_object_base.hpp	/^	btVector3 _angular_x;$/;"	m	class:_object_base
_angular_y	_object_base.hpp	/^	btVector3 _angular_y;$/;"	m	class:_object_base
_angular_z	_object_base.hpp	/^	btVector3 _angular_z;$/;"	m	class:_object_base
_asset_manager	_asset_manager.cpp	/^_asset_manager::_asset_manager(void) {}$/;"	f	class:_asset_manager
_asset_manager	_asset_manager.hpp	/^class _asset_manager {$/;"	c
_be_catched_camera_ID	_object_base.hpp	/^	int _be_catched_camera_ID;$/;"	m	class:_object_base
_be_catched_controller_ID	_object_base.hpp	/^	int _be_catched_controller_ID;$/;"	m	class:_object_base
_bind_uniform_variable_to_shader	_shader_manager.cpp	/^void _shader_manager::_bind_uniform_variable_to_shader (void) {$/;"	f	class:_shader_manager
_broadphase	_scene_base.hpp	/^	std::shared_ptr<btDbvtBroadphase> _broadphase;$/;"	m	class:_scene_base
_camera_base	_camera_base.cpp	/^_camera_base::_camera_base (void) : _object_base(), _perspective_matrix(1) {}$/;"	f	class:_camera_base
_camera_base	_camera_base.hpp	/^class _camera_base : public _object_base {$/;"	c
_camera_controller_matrix	_controller_base.hpp	/^	glm::mat4 _camera_controller_matrix;$/;"	m	class:_controller_base
_cameras_in_scene	_scene_base.hpp	/^	std::list<std::shared_ptr<_camera_base>> _cameras_in_scene;$/;"	m	class:_scene_base
_cameras_in_scene_iter	_scene_base.hpp	/^	std::list<std::shared_ptr<_camera_base>>::iterator _cameras_in_scene_iter;$/;"	m	class:_scene_base
_clock	_scene_base.hpp	/^	btClock _clock;$/;"	m	class:_scene_base
_collision_configuration	_scene_base.hpp	/^	std::shared_ptr<btDefaultCollisionConfiguration> _collision_configuration;$/;"	m	class:_scene_base
_controller_base	_controller_base.cpp	/^_controller_base::_controller_base (void) : _object_base() {}$/;"	f	class:_controller_base
_controller_base	_controller_base.hpp	/^class _controller_base : public _object_base {$/;"	c
_controller_in_scene	_scene_base.hpp	/^	std::shared_ptr<_controller_base> _controller_in_scene;$/;"	m	class:_scene_base
_cube_data	_model_manager.hpp	/^	std::vector<triangle> _cube_data;$/;"	m	class:cube
_current_shader	_scene_base.hpp	/^	std::shared_ptr<_shader_manager> _current_shader;$/;"	m	class:_scene_base
_data	_model_manager.hpp	/^	std::vector<triangle> _data;$/;"	m	class:_model_manager
_diffuse_color	_light_base.hpp	/^	glm::vec4 _diffuse_color,$/;"	m	class:_light_base
_diffuse_colors	_light_base_set.hpp	/^	std::vector<glm::vec4> _diffuse_colors;$/;"	m	class:_light_base_set
_dispatcher	_scene_base.hpp	/^	std::shared_ptr<btCollisionDispatcher> _dispatcher;$/;"	m	class:_scene_base
_extractNameFromString	_shader_manager.cpp	/^void _shader_manager::_extractNameFromString (std::vector<std::string>& extractNames, const std::string originNames) {$/;"	f	class:_shader_manager
_float_number	_asset_manager.hpp	/^	GLuint _float_number;$/;"	m	class:_asset_manager
_float_number	_model_manager.hpp	/^	GLuint _float_number;$/;"	m	class:_model_manager
_force	_object_base.hpp	/^	btVector3 _force;$/;"	m	class:_object_base
_inertia	_object_base.hpp	/^	btVector3 _inertia;$/;"	m	class:_object_base
_is_be_controlled	_object_base.hpp	/^	bool _is_be_controlled;$/;"	m	class:_object_base
_is_catch_camera	_object_base.hpp	/^	bool _is_catch_camera;$/;"	m	class:_object_base
_is_destoried	_object_base.hpp	/^	bool _is_destoried;$/;"	m	class:_object_base
_light_base	_light_base.cpp	/^_light_base::_light_base (void) : _object_base(), _diffuse_color(), _light_position() {}$/;"	f	class:_light_base
_light_base	_light_base.hpp	/^class _light_base : public _object_base {$/;"	c
_light_base_set	_light_base_set.cpp	/^_light_base_set::_light_base_set (void) : _lights(), _diffuse_colors() {}$/;"	f	class:_light_base_set
_light_base_set	_light_base_set.hpp	/^class _light_base_set {$/;"	c
_light_base_set_in_scene	_scene_base.hpp	/^	std::shared_ptr<_light_base_set> _light_base_set_in_scene;$/;"	m	class:_scene_base
_light_position	_light_base.hpp	/^	_light_position;$/;"	m	class:_light_base
_lights	_light_base_set.hpp	/^	std::list<std::shared_ptr<_light_base>> _lights;$/;"	m	class:_light_base_set
_lights_count	_light_base_set.hpp	/^	int _lights_count;$/;"	m	class:_light_base_set
_lights_iter	_light_base_set.hpp	/^	std::list<std::shared_ptr<_light_base>>::iterator _lights_iter;$/;"	m	class:_light_base_set
_lights_positions	_light_base_set.hpp	/^	std::vector<glm::vec3> _lights_positions;$/;"	m	class:_light_base_set
_mass	_object_base.hpp	/^	btScalar _mass;$/;"	m	class:_object_base
_material_diffuse_color	_object_base.hpp	/^	glm::vec4 _material_diffuse_color;$/;"	m	class:_object_base
_material_specular_color	_object_base.hpp	/^	glm::vec4 _material_specular_color;$/;"	m	class:_object_base
_matrix_catch_camera_in_world	_object_base.hpp	/^	glm::mat4 _matrix_catch_camera_in_world;$/;"	m	class:_object_base
_matrix_follow_in_world	_object_base.hpp	/^	glm::mat4 _matrix_follow_in_world;$/;"	m	class:_object_base
_matrix_in_camera_world	_object_base.hpp	/^	glm::mat4 _matrix_in_camera_world;$/;"	m	class:_object_base
_matrix_in_world	_object_base.hpp	/^	glm::mat4 _matrix_in_world;$/;"	m	class:_object_base
_message	_controller_base.hpp	/^	std::vector<control_message> _message;$/;"	m	class:_controller_base
_model	_object_base.hpp	/^	_model_manager _model;$/;"	m	class:_object_base
_model_data	_asset_manager.hpp	/^	std::vector<triangle> _model_data;$/;"	m	class:_asset_manager
_model_data_iter	_asset_manager.hpp	/^	std::vector<triangle>::iterator _model_data_iter;$/;"	m	class:_asset_manager
_model_manager	_model_manager.cpp	/^_model_manager::_model_manager (void) : _data(), _float_number(0), _vertex_number(0), _triangle_number(0), _vbo(0), _vao(0) {$/;"	f	class:_model_manager
_model_manager	_model_manager.hpp	/^class _model_manager {$/;"	c
_models_data	_asset_manager.hpp	/^	std::map<std::string, std::vector<triangle>> _models_data;$/;"	m	class:_asset_manager
_models_data_iter	_asset_manager.hpp	/^	std::map<std::string, std::vector<triangle>>::iterator _models_data_iter;$/;"	m	class:_asset_manager
_motion_state	_object_base.hpp	/^	std::shared_ptr<btDefaultMotionState> _motion_state;$/;"	m	class:_object_base
_normal_data	_asset_manager.hpp	/^	std::vector<triangle> _normal_data;$/;"	m	class:_asset_manager
_normal_data	_model_manager.hpp	/^	std::vector<triangle> _normal_data;$/;"	m	class:_model_manager
_object_base	_object_base.cpp	/^_object_base::_object_base (void) :	_matrix_catch_camera_in_world( 1 ),$/;"	f	class:_object_base
_object_base	_object_base.hpp	/^class _object_base {$/;"	c
_object_controller_matrix	_controller_base.hpp	/^	glm::mat4 _object_controller_matrix;$/;"	m	class:_controller_base
_object_motion_state	_controller_base.hpp	/^	int _object_motion_state;$/;"	m	class:_controller_base
_objects_in_scene_iter	_scene_base.hpp	/^	std::list<std::shared_ptr<_object_base>>::iterator _objects_in_scene_iter;$/;"	m	class:_scene_base
_perspective_matrix	_camera_base.hpp	/^	glm::mat4 _perspective_matrix;$/;"	m	class:_camera_base
_physics_world	_scene_base.hpp	/^	std::shared_ptr<btDiscreteDynamicsWorld> _physics_world;$/;"	m	class:_scene_base
_position_in_world	_object_base.hpp	/^	glm::vec4 _position_in_world;$/;"	m	class:_object_base
_rigid_body	_object_base.hpp	/^	std::shared_ptr<btRigidBody> _rigid_body;$/;"	m	class:_object_base
_scene_base	_scene_base.cpp	/^_scene_base::_scene_base (void) :	_current_shader( nullptr ),$/;"	f	class:_scene_base
_scene_base	_scene_base.hpp	/^class _scene_base {$/;"	c
_shader	_shader_manager.hpp	/^	GLuint _shader;$/;"	m	class:_shader_manager
_shaderManage	_shader_manager.hpp	/^	ShaderManage _shaderManage;$/;"	m	class:_shader_manager
_shader_manager	_shader_manager.cpp	/^_shader_manager::_shader_manager (void) : _shaderManage (), _shader (), _uniformNames () {}$/;"	f	class:_shader_manager
_shader_manager	_shader_manager.hpp	/^class _shader_manager {$/;"	c
_shaders	_scene_base.hpp	/^	std::unordered_map<unsigned int, std::shared_ptr<_shader_manager>> _shaders;$/;"	m	class:_scene_base
_shaders_and_objects_in_scene	_scene_base.hpp	/^	std::unordered_map<unsigned int, std::list<std::shared_ptr<_object_base>>> _shaders_and_objects_in_scene;$/;"	m	class:_scene_base
_shaders_and_objects_in_scene_iter	_scene_base.hpp	/^	std::unordered_map<unsigned int, std::list<std::shared_ptr<_object_base>>>::iterator _shaders_and_objects_in_scene_iter;$/;"	m	class:_scene_base
_shape	_object_base.hpp	/^	std::shared_ptr<btCollisionShape> _shape;$/;"	m	class:_object_base
_side_length	_model_manager.hpp	/^	float _side_length;$/;"	m	class:cube
_solver	_scene_base.hpp	/^	std::shared_ptr<btSequentialImpulseConstraintSolver> _solver;$/;"	m	class:_scene_base
_specular_color	_light_base.hpp	/^	_specular_color,$/;"	m	class:_light_base
_specular_colors	_light_base_set.hpp	/^	std::vector<glm::vec4> _specular_colors;$/;"	m	class:_light_base_set
_start_vertex	_model_manager.hpp	/^	glm::vec3 _start_vertex;$/;"	m	class:cube
_state	_object_base.hpp	/^	int _state;$/;"	m	class:_object_base
_triangle	_model_manager.hpp	/^	triangle _triangle;$/;"	m	class:cube
_triangle_number	_asset_manager.hpp	/^	GLuint _triangle_number;$/;"	m	class:_asset_manager
_triangle_number	_model_manager.hpp	/^	GLuint _triangle_number;$/;"	m	class:_model_manager
_uniformNames	_shader_manager.hpp	/^	std::unordered_map<std::string, GLuint> _uniformNames;$/;"	m	class:_shader_manager
_vao	_model_manager.hpp	/^	GLuint _vao;$/;"	m	class:_model_manager
_vbo	_model_manager.hpp	/^	GLuint _vbo;$/;"	m	class:_model_manager
_vertex_data	_asset_manager.hpp	/^	std::vector<triangle> _vertex_data;$/;"	m	class:_asset_manager
_vertex_data	_model_manager.hpp	/^	std::vector<triangle> _vertex_data;$/;"	m	class:_model_manager
_vertex_number	_asset_manager.hpp	/^	GLuint _vertex_number;$/;"	m	class:_asset_manager
_vertex_number	_model_manager.hpp	/^	GLuint _vertex_number;$/;"	m	class:_model_manager
a	_model_manager.hpp	/^	glm::vec3	a,$/;"	m	class:cube
a1	_model_manager.hpp	/^			a1;$/;"	m	class:cube
add_camera	_scene_base.cpp	/^void _scene_base::add_camera ( _camera_base* camera ) {$/;"	f	class:_scene_base
add_light	_light_base_set.cpp	/^void _light_base_set::add_light ( _light_base* light ) {$/;"	f	class:_light_base_set
add_light	_scene_base.cpp	/^void _scene_base::add_light ( _light_base* light ) {$/;"	f	class:_scene_base
add_object	_scene_base.cpp	/^void _scene_base::add_object ( _object_base* object, const unsigned int shader_name ) {$/;"	f	class:_scene_base
ambient_color	_shader_manager.hpp	/^	       ambient_color,$/;"	m	class:_shader_manager
apply_physics	_object_base.cpp	/^void _object_base::apply_physics (void) {$/;"	f	class:_object_base
apply_physics_transform_update	_object_base.cpp	/^void _object_base::apply_physics_transform_update (void) {$/;"	f	class:_object_base
attribute	testshadermanage.cpp	/^vector<GLuint> attribute;$/;"	v
attributeIndex	ShaderManage.hpp	/^	std::map<GLuint, std::string> attributeIndex;$/;"	m	class:ShaderManage
attributeName	ShaderManage.hpp	/^	std::string* attributeName;$/;"	m	class:ShaderManage
b	_model_manager.hpp	/^			b,$/;"	m	class:cube
b1	_model_manager.hpp	/^			b1,$/;"	m	class:cube
be_catched_camera_ID	_object_base.hpp	/^	inline int be_catched_camera_ID (void) const { return _be_catched_camera_ID; }$/;"	f	class:_object_base
c	_model_manager.hpp	/^			c,$/;"	m	class:cube
c1	_model_manager.hpp	/^			c1,$/;"	m	class:cube
camera_transforms	_shader_manager.hpp	/^	       camera_transforms,$/;"	m	class:_shader_manager
catch_camera	_object_base.hpp	/^	inline void catch_camera ( const unsigned int camera_ID ) { _is_catch_camera = true; _be_catched_camera_ID = camera_ID; }$/;"	f	class:_object_base
catch_contrtoller	_object_base.hpp	/^	inline void catch_contrtoller ( void ) { _is_be_controlled = true; }$/;"	f	class:_object_base
control_message	_object_base.hpp	/^	control_message( int m, int m_i ) : msg(m), msg_info(m_i) {}$/;"	f	struct:control_message
control_message	_object_base.hpp	/^struct control_message {$/;"	s
create_shader	_shader_manager.cpp	/^GLuint _shader_manager::create_shader (const std::string shaderSourceName) {$/;"	f	class:_shader_manager
cube	_model_manager.hpp	/^class cube {$/;"	c
cube_info	_model_manager.hpp	/^	struct cube_info {$/;"	s	class:cube
d	_model_manager.hpp	/^			d;$/;"	m	class:cube
d1	_model_manager.hpp	/^	glm::vec3	d1,$/;"	m	class:cube
destory	_object_base.cpp	/^void _object_base::destory (void) {}$/;"	f	class:_object_base
diffuse_color	_shader_manager.hpp	/^	       diffuse_color,$/;"	m	class:_shader_manager
draw	_model_manager.cpp	/^void _model_manager::draw (void) {$/;"	f	class:_model_manager
draw	_object_base.cpp	/^void _object_base::draw (void) {$/;"	f	class:_object_base
edit_modedl	_model_manager.cpp	/^void _model_manager::edit_modedl (void) {$/;"	f	class:_model_manager
edit_scene	_scene_base.cpp	/^void _scene_base::edit_scene (void) {}$/;"	f	class:_scene_base
edit_scene	fulcrum.cpp	/^void game_scene::edit_scene (void) {$/;"	f	class:game_scene
follow	_camera_base.cpp	/^void _camera_base::follow ( const _object_base* be_followed_object, bool is_rotate ) {}$/;"	f	class:_camera_base
follow	_object_base.cpp	/^void _object_base::follow ( const _object_base* be_followed_object, bool is_rotate) {$/;"	f	class:_object_base
gContext	fulcrum.cpp	/^SDL_GLContext gContext;$/;"	v
gIBO	fulcrum.cpp	/^GLuint gIBO = 0;$/;"	v
gProgramID	fulcrum.cpp	/^GLuint gProgramID = 0;$/;"	v
gRenderQuad	fulcrum.cpp	/^bool gRenderQuad = true;$/;"	v
gVBO	fulcrum.cpp	/^GLuint gVBO = 0;$/;"	v
gVertexPos2DLocation	fulcrum.cpp	/^GLint gVertexPos2DLocation = -1;$/;"	v
gWindow	fulcrum.cpp	/^SDL_Window* gWindow = nullptr;$/;"	v
game_camera	fulcrum.cpp	/^class game_camera : public _camera_base {$/;"	c	file:
game_camera	fulcrum.cpp	/^game_camera::game_camera (void) : _camera_base() {}$/;"	f	class:game_camera
game_object	fulcrum.cpp	/^class game_object : public _object_base {$/;"	c	file:
game_object	fulcrum.cpp	/^game_object::game_object (void) : _object_base() {}$/;"	f	class:game_object
game_scene	fulcrum.cpp	/^class game_scene : public _scene_base {$/;"	c	file:
game_scene	fulcrum.cpp	/^game_scene::game_scene (void) : _scene_base() {}$/;"	f	class:game_scene
generate_another_cube	_model_manager.hpp	/^	void generate_another_cube ( const int& side ) {$/;"	f	class:cube
generate_cube	_model_manager.hpp	/^	void generate_cube ( const glm::vec3& start_vertex, const float& side_length ) {$/;"	f	class:cube
generate_cube_vertexs	_model_manager.hpp	/^	void generate_cube_vertexs ( glm::vec3 start_vertex, float side_length ) {$/;"	f	class:cube
generate_cude_side	_model_manager.hpp	/^	void generate_cude_side ( const glm::vec3& a, const glm::vec3& b, const glm::vec3& c, const glm::vec3& d ) {$/;"	f	class:cube
generate_model	_object_base.hpp	/^	inline void generate_model (void) {$/;"	f	class:_object_base
generate_normal_data	_model_manager.cpp	/^void _model_manager::generate_normal_data (void) {$/;"	f	class:_model_manager
generate_vertex_data	_model_manager.cpp	/^void _model_manager::generate_vertex_data(void) {$/;"	f	class:_model_manager
get_ID	_object_base.hpp	/^	inline int get_ID (void) const { return _ID; }$/;"	f	class:_object_base
get_ambient_color	_scene_base.hpp	/^	inline glm::vec4 get_ambient_color (void) const { return _ambient_color_in_scene; }$/;"	f	class:_scene_base
get_camera_controller_matrix	_controller_base.hpp	/^	inline glm::mat4 get_camera_controller_matrix (void) const { return _camera_controller_matrix; }$/;"	f	class:_controller_base
get_controller	_scene_base.hpp	/^	inline _controller_base* get_controller (void) const { return _controller_in_scene.get(); }$/;"	f	class:_scene_base
get_data	_model_manager.hpp	/^	inline const std::vector<triangle>& get_data (void) const { return _data; }$/;"	f	class:_model_manager
get_data	_model_manager.hpp	/^	inline std::vector<triangle> get_data ( void ) { return _cube_data; }$/;"	f	class:cube
get_diffuse_color	_light_base.hpp	/^	inline glm::vec4 get_diffuse_color (void) const { return _diffuse_color; }$/;"	f	class:_light_base
get_lights	_light_base_set.hpp	/^	inline std::list<std::shared_ptr<_light_base>> get_lights ( void ) const { return _lights; }$/;"	f	class:_light_base_set
get_local_position_in_world	_object_base.hpp	/^	inline glm::vec4 get_local_position_in_world (void) const { return glm::vec4( glm::vec3( _matrix_in_world[3] ), 1.0F ); }$/;"	f	class:_object_base
get_matrix_follow_in_world	_object_base.hpp	/^	inline glm::mat4 get_matrix_follow_in_world (void) const { return _matrix_follow_in_world; }$/;"	f	class:_object_base
get_matrix_in_camera_world	_object_base.hpp	/^	inline glm::mat4 get_matrix_in_camera_world (void) const { return _matrix_in_camera_world; }$/;"	f	class:_object_base
get_matrix_in_world	_object_base.hpp	/^	inline glm::mat4 get_matrix_in_world (void) const { return _matrix_in_world * _matrix_follow_in_world; }$/;"	f	class:_object_base
get_message	_controller_base.hpp	/^	const std::vector<control_message>& get_message ( void ) const { return _message; }$/;"	f	class:_controller_base
get_model_data	_asset_manager.hpp	/^	const std::vector<triangle>& get_model_data ( const std::string& model_name ) {$/;"	f	class:_asset_manager
get_model_data	_object_base.hpp	/^	inline const std::vector<triangle>& get_model_data(void) const { _model.get_data(); }$/;"	f	class:_object_base
get_object_controller_matrix	_controller_base.hpp	/^	inline glm::mat4 get_object_controller_matrix (void) const { return _object_controller_matrix; }$/;"	f	class:_controller_base
get_object_motion_state	_controller_base.hpp	/^	inline int get_object_motion_state (void) const { return _object_motion_state; }$/;"	f	class:_controller_base
get_perspective	_camera_base.hpp	/^	inline glm::mat4 get_perspective (void) const { return _perspective_matrix; }$/;"	f	class:_camera_base
get_physics_world	_scene_base.hpp	/^	inline btDiscreteDynamicsWorld* get_physics_world (void) const { return _physics_world.get(); }$/;"	f	class:_scene_base
get_rigidbody	_object_base.hpp	/^	inline btRigidBody* get_rigidbody (void) const { return _rigid_body.get(); }$/;"	f	class:_object_base
get_shader	_shader_manager.hpp	/^	inline GLuint get_shader (void) const { return _shader; }$/;"	f	class:_shader_manager
get_specular_color	_light_base.hpp	/^	inline glm::vec4 get_specular_color (void) const { return _specular_color; }$/;"	f	class:_light_base
get_test_shader	_scene_base.hpp	/^	inline _shader_manager* get_test_shader (void) { return _current_shader.get(); }$/;"	f	class:_scene_base
init	fulcrum.cpp	/^bool init () {$/;"	f
init	testshadermanage.cpp	/^void init() {$/;"	f
init_rigid_body	_object_base.cpp	/^void _object_base::init_rigid_body ( const btScalar mass, const btVector3 inertia, btCollisionShape* shape ) {$/;"	f	class:_object_base
init_scene	fulcrum.cpp	/^void init_scene ( void ) {$/;"	f
initialize_vao	_model_manager.cpp	/^void _model_manager::initialize_vao (void) {$/;"	f	class:_model_manager
initialize_vbo	_model_manager.cpp	/^void _model_manager::initialize_vbo (void) {$/;"	f	class:_model_manager
initilize_scene	_scene_base.cpp	/^void _scene_base::initilize_scene (void) {$/;"	f	class:_scene_base
is_be_controlled	_object_base.hpp	/^	inline bool is_be_controlled (void) const { return _is_be_controlled; }$/;"	f	class:_object_base
is_catch_camera	_object_base.hpp	/^	inline bool is_catch_camera (void) const { return _is_catch_camera; }$/;"	f	class:_object_base
is_destory	_object_base.hpp	/^	inline bool is_destory (void) const { return _is_destoried; }$/;"	f	class:_object_base
light_color	_shader_manager.hpp	/^	       light_color,$/;"	m	class:_shader_manager
light_position	_shader_manager.hpp	/^	       light_position,$/;"	m	class:_shader_manager
light_transforms	_shader_manager.hpp	/^	       light_transforms,$/;"	m	class:_shader_manager
lights_count	_shader_manager.hpp	/^	       lights_count,$/;"	m	class:_shader_manager
load_model_data_from_assets	_model_manager.cpp	/^bool _model_manager::load_model_data_from_assets ( const std::vector<triangle>& model_data ) {$/;"	f	class:_model_manager
load_model_data_from_assets	_object_base.hpp	/^	bool load_model_data_from_assets ( const std::vector<triangle>& model_data ) {$/;"	f	class:_object_base
load_scene	_scene_base.cpp	/^void _scene_base::load_scene (void) {$/;"	f	class:_scene_base
m3dAddVectors2	math3d.h	/^inline void m3dAddVectors2(M3DVector2d r, const M3DVector2d a, const M3DVector2d b)$/;"	f
m3dAddVectors2	math3d.h	/^inline void m3dAddVectors2(M3DVector2f r, const M3DVector2f a, const M3DVector2f b)$/;"	f
m3dAddVectors3	math3d.h	/^inline void m3dAddVectors3(M3DVector3d r, const M3DVector3d a, const M3DVector3d b)$/;"	f
m3dAddVectors3	math3d.h	/^inline void m3dAddVectors3(M3DVector3f r, const M3DVector3f a, const M3DVector3f b)$/;"	f
m3dAddVectors4	math3d.h	/^inline void m3dAddVectors4(M3DVector4d r, const M3DVector4d a, const M3DVector4d b)$/;"	f
m3dAddVectors4	math3d.h	/^inline void m3dAddVectors4(M3DVector4f r, const M3DVector4f a, const M3DVector4f b)$/;"	f
m3dCalculateTangentBasis	math3d.cpp	/^void m3dCalculateTangentBasis(M3DVector3f vTangent, const M3DVector3f vTriangle[3], const M3DVector2f vTexCoords[3], const M3DVector3f N)$/;"	f
m3dCatmullRom	math3d.cpp	/^void m3dCatmullRom(M3DVector3d vOut, const M3DVector3d vP0, const M3DVector3d vP1, const M3DVector3d vP2, const M3DVector3d vP3, double t)$/;"	f
m3dCatmullRom	math3d.cpp	/^void m3dCatmullRom(M3DVector3f vOut, const M3DVector3f vP0, const M3DVector3f vP1, const M3DVector3f vP2, const M3DVector3f vP3, float t)$/;"	f
m3dCloseEnough	math3d.h	/^inline bool m3dCloseEnough(const double dCandidate, const double dCompare, const double dEpsilon)$/;"	f
m3dCloseEnough	math3d.h	/^inline bool m3dCloseEnough(const float fCandidate, const float fCompare, const float fEpsilon)$/;"	f
m3dClosestPointOnRay	math3d.cpp	/^double m3dClosestPointOnRay(M3DVector3d vPointOnRay, const M3DVector3d vRayOrigin, const M3DVector3d vUnitRayDir, $/;"	f
m3dClosestPointOnRay	math3d.cpp	/^float m3dClosestPointOnRay(M3DVector3f vPointOnRay, const M3DVector3f vRayOrigin, const M3DVector3f vUnitRayDir, $/;"	f
m3dCopyMatrix33	math3d.h	/^inline void m3dCopyMatrix33(M3DMatrix33d dst, const M3DMatrix33d src)$/;"	f
m3dCopyMatrix33	math3d.h	/^inline void m3dCopyMatrix33(M3DMatrix33f dst, const M3DMatrix33f src)$/;"	f
m3dCopyMatrix44	math3d.h	/^inline void m3dCopyMatrix44(M3DMatrix44d dst, const M3DMatrix44d src)$/;"	f
m3dCopyMatrix44	math3d.h	/^inline void m3dCopyMatrix44(M3DMatrix44f dst, const M3DMatrix44f src)$/;"	f
m3dCopyVector2	math3d.h	/^inline void	m3dCopyVector2(M3DVector2d dst, const M3DVector2d src) { memcpy(dst, src, sizeof(M3DVector2d)); }$/;"	f
m3dCopyVector2	math3d.h	/^inline void	m3dCopyVector2(M3DVector2f dst, const M3DVector2f src) { memcpy(dst, src, sizeof(M3DVector2f)); }$/;"	f
m3dCopyVector3	math3d.h	/^inline void	m3dCopyVector3(M3DVector3d dst, const M3DVector3d src) { memcpy(dst, src, sizeof(M3DVector3d)); }$/;"	f
m3dCopyVector3	math3d.h	/^inline void	m3dCopyVector3(M3DVector3f dst, const M3DVector3f src) { memcpy(dst, src, sizeof(M3DVector3f)); }$/;"	f
m3dCopyVector4	math3d.h	/^inline void	m3dCopyVector4(M3DVector4d dst, const M3DVector4d src) { memcpy(dst, src, sizeof(M3DVector4d)); }$/;"	f
m3dCopyVector4	math3d.h	/^inline void	m3dCopyVector4(M3DVector4f dst, const M3DVector4f src) { memcpy(dst, src, sizeof(M3DVector4f)); }$/;"	f
m3dCrossProduct3	math3d.h	/^inline void m3dCrossProduct3(M3DVector3d result, const M3DVector3d u, const M3DVector3d v)$/;"	f
m3dCrossProduct3	math3d.h	/^inline void m3dCrossProduct3(M3DVector3f result, const M3DVector3f u, const M3DVector3f v)$/;"	f
m3dDegToHr	math3d.h	107;"	d
m3dDegToRad	math3d.h	100;"	d
m3dDotProduct3	math3d.h	/^inline double m3dDotProduct3(const M3DVector3d u, const M3DVector3d v)$/;"	f
m3dDotProduct3	math3d.h	/^inline float m3dDotProduct3(const M3DVector3f u, const M3DVector3f v)$/;"	f
m3dExtractRotationMatrix33	math3d.h	/^inline void m3dExtractRotationMatrix33(M3DMatrix33d dst, const M3DMatrix44d src)$/;"	f
m3dExtractRotationMatrix33	math3d.h	/^inline void m3dExtractRotationMatrix33(M3DMatrix33f dst, const M3DMatrix44f src)$/;"	f
m3dFindNormal	math3d.cpp	/^void m3dFindNormal(M3DVector3d result, const M3DVector3d point1, const M3DVector3d point2, $/;"	f
m3dFindNormal	math3d.cpp	/^void m3dFindNormal(M3DVector3f result, const M3DVector3f point1, const M3DVector3f point2, $/;"	f
m3dGetAngleBetweenVectors3	math3d.h	/^inline double m3dGetAngleBetweenVectors3(const M3DVector3d u, const M3DVector3d v)$/;"	f
m3dGetAngleBetweenVectors3	math3d.h	/^inline float m3dGetAngleBetweenVectors3(const M3DVector3f u, const M3DVector3f v)$/;"	f
m3dGetDistance3	math3d.h	/^inline double m3dGetDistance3(const M3DVector3d u, const M3DVector3d v)$/;"	f
m3dGetDistance3	math3d.h	/^inline float m3dGetDistance3(const M3DVector3f u, const M3DVector3f v)$/;"	f
m3dGetDistanceSquared3	math3d.cpp	/^double m3dGetDistanceSquared3(const M3DVector3d u, const M3DVector3d v)$/;"	f
m3dGetDistanceSquared3	math3d.cpp	/^float m3dGetDistanceSquared3(const M3DVector3f u, const M3DVector3f v)$/;"	f
m3dGetDistanceToPlane	math3d.h	/^inline double m3dGetDistanceToPlane(const M3DVector3d point, const M3DVector4d plane)$/;"	f
m3dGetDistanceToPlane	math3d.h	/^inline float m3dGetDistanceToPlane(const M3DVector3f point, const M3DVector4f plane)$/;"	f
m3dGetMagnitude3	math3d.h	/^inline double m3dGetMagnitude3(const M3DVector3d u) { return sqrt(m3dGetMagnitudeSquared3(u)); }$/;"	f
m3dGetMagnitude3	math3d.h	/^inline float m3dGetMagnitude3(const M3DVector3f u) { return sqrtf(m3dGetMagnitudeSquared3(u)); }$/;"	f
m3dGetMagnitudeSquared3	math3d.h	/^inline double m3dGetMagnitudeSquared3(const M3DVector3d u) { return u[0]*u[0] + u[1]*u[1] + u[2]*u[2]; }$/;"	f
m3dGetMagnitudeSquared3	math3d.h	/^inline float m3dGetMagnitudeSquared3(const M3DVector3f u) { return u[0]*u[0] + u[1]*u[1] + u[2]*u[2]; }$/;"	f
m3dGetMatrixColumn33	math3d.h	/^inline void m3dGetMatrixColumn33(M3DVector3d dst, const M3DMatrix33d src, const int column)$/;"	f
m3dGetMatrixColumn33	math3d.h	/^inline void m3dGetMatrixColumn33(M3DVector3f dst, const M3DMatrix33f src, const int column)$/;"	f
m3dGetMatrixColumn44	math3d.h	/^inline void m3dGetMatrixColumn44(M3DVector4d dst, const M3DMatrix44d src, const int column)$/;"	f
m3dGetMatrixColumn44	math3d.h	/^inline void m3dGetMatrixColumn44(M3DVector4f dst, const M3DMatrix44f src, const int column)$/;"	f
m3dGetPlaneEquation	math3d.cpp	/^void m3dGetPlaneEquation(M3DVector4d planeEq, const M3DVector3d p1, const M3DVector3d p2, const M3DVector3d p3)$/;"	f
m3dGetPlaneEquation	math3d.cpp	/^void m3dGetPlaneEquation(M3DVector4f planeEq, const M3DVector3f p1, const M3DVector3f p2, const M3DVector3f p3)$/;"	f
m3dGetVectorLength3	math3d.h	/^inline double m3dGetVectorLength3(const M3DVector3d u)$/;"	f
m3dGetVectorLength3	math3d.h	/^inline float m3dGetVectorLength3(const M3DVector3f u)$/;"	f
m3dGetVectorLengthSquared3	math3d.h	/^inline double m3dGetVectorLengthSquared3(const M3DVector3d u)$/;"	f
m3dGetVectorLengthSquared3	math3d.h	/^inline float m3dGetVectorLengthSquared3(const M3DVector3f u)$/;"	f
m3dGetVectorW	math3d.h	136;"	d
m3dGetVectorX	math3d.h	133;"	d
m3dGetVectorY	math3d.h	134;"	d
m3dGetVectorZ	math3d.h	135;"	d
m3dHrToDeg	math3d.h	104;"	d
m3dHrToRad	math3d.h	105;"	d
m3dInjectRotationMatrix44	math3d.h	/^inline void m3dInjectRotationMatrix44(M3DMatrix44d dst, const M3DMatrix33d src)$/;"	f
m3dInjectRotationMatrix44	math3d.h	/^inline void m3dInjectRotationMatrix44(M3DMatrix44f dst, const M3DMatrix33f src)$/;"	f
m3dInvertMatrix44	math3d.cpp	/^void m3dInvertMatrix44(M3DMatrix44d mInverse, const M3DMatrix44d m)$/;"	f
m3dInvertMatrix44	math3d.cpp	/^void m3dInvertMatrix44(M3DMatrix44f mInverse, const M3DMatrix44f m)$/;"	f
m3dIsPOW2	math3d.h	/^inline unsigned int m3dIsPOW2(unsigned int iValue)$/;"	f
m3dLoadIdentity33	math3d.cpp	/^void m3dLoadIdentity33(M3DMatrix33d m)$/;"	f
m3dLoadIdentity33	math3d.cpp	/^void m3dLoadIdentity33(M3DMatrix33f m)$/;"	f
m3dLoadIdentity44	math3d.cpp	/^void m3dLoadIdentity44(M3DMatrix44d m)$/;"	f
m3dLoadIdentity44	math3d.cpp	/^void m3dLoadIdentity44(M3DMatrix44f m)$/;"	f
m3dLoadVector2	math3d.h	/^inline void m3dLoadVector2(M3DVector2d v, const float x, const float y)$/;"	f
m3dLoadVector2	math3d.h	/^inline void m3dLoadVector2(M3DVector2f v, const float x, const float y)$/;"	f
m3dLoadVector3	math3d.h	/^inline void m3dLoadVector3(M3DVector3d v, const double x, const double y, const double z)$/;"	f
m3dLoadVector3	math3d.h	/^inline void m3dLoadVector3(M3DVector3f v, const float x, const float y, const float z) $/;"	f
m3dLoadVector4	math3d.h	/^inline void m3dLoadVector4(M3DVector4d v, const double x, const double y, const double z, const double w)$/;"	f
m3dLoadVector4	math3d.h	/^inline void m3dLoadVector4(M3DVector4f v, const float x, const float y, const float z, const float w) $/;"	f
m3dMakeOrthographicMatrix	math3d.cpp	/^void m3dMakeOrthographicMatrix(M3DMatrix44f mProjection, float xMin, float xMax, float yMin, float yMax, float zMin, float zMax)$/;"	f
m3dMakePerspectiveMatrix	math3d.cpp	/^void m3dMakePerspectiveMatrix(M3DMatrix44f mProjection, float fFov, float fAspect, float zMin, float zMax)$/;"	f
m3dMakePlanarShadowMatrix	math3d.cpp	/^void m3dMakePlanarShadowMatrix(M3DMatrix44d proj, const M3DVector4d planeEq, const M3DVector3f vLightPos)$/;"	f
m3dMakePlanarShadowMatrix	math3d.cpp	/^void m3dMakePlanarShadowMatrix(M3DMatrix44f proj, const M3DVector4f planeEq, const M3DVector3f vLightPos)$/;"	f
m3dMatrixMultiply	math3d.cpp	/^void m3dMatrixMultiply(M3DMatrix44d product, const M3DMatrix44d a, const M3DMatrix44d b )$/;"	f
m3dMatrixMultiply33	math3d.cpp	/^void m3dMatrixMultiply33(M3DMatrix33f product, const M3DMatrix33f a, const M3DMatrix33f b )$/;"	f
m3dMatrixMultiply44	math3d.cpp	/^void m3dMatrixMultiply44(M3DMatrix33d product, const M3DMatrix33d a, const M3DMatrix33d b )$/;"	f
m3dMatrixMultiply44	math3d.cpp	/^void m3dMatrixMultiply44(M3DMatrix44f product, const M3DMatrix44f a, const M3DMatrix44f b )$/;"	f
m3dNormalizeVector3	math3d.h	/^inline void m3dNormalizeVector3(M3DVector3d u)$/;"	f
m3dNormalizeVector3	math3d.h	/^inline void m3dNormalizeVector3(M3DVector3f u)$/;"	f
m3dProjectXY	math3d.cpp	/^void m3dProjectXY(M3DVector2f vPointOut, const M3DMatrix44f mModelView, const M3DMatrix44f mProjection, const int iViewPort[4], const M3DVector3f vPointIn)$/;"	f
m3dProjectXYZ	math3d.cpp	/^void m3dProjectXYZ(M3DVector3f vPointOut, const M3DMatrix44f mModelView, const M3DMatrix44f mProjection, const int iViewPort[4], const M3DVector3f vPointIn)$/;"	f
m3dRadToDeg	math3d.h	101;"	d
m3dRadToHr	math3d.h	108;"	d
m3dRaySphereTest	math3d.cpp	/^double m3dRaySphereTest(const M3DVector3d point, const M3DVector3d ray, const M3DVector3d sphereCenter, double sphereRadius)$/;"	f
m3dRaySphereTest	math3d.cpp	/^float m3dRaySphereTest(const M3DVector3f point, const M3DVector3f ray, const M3DVector3f sphereCenter, float sphereRadius)$/;"	f
m3dRotateVector	math3d.h	/^__inline void m3dRotateVector(M3DVector3d vOut, const M3DVector3d p, const M3DMatrix33d m)$/;"	f
m3dRotateVector	math3d.h	/^__inline void m3dRotateVector(M3DVector3f vOut, const M3DVector3f p, const M3DMatrix33f m)$/;"	f
m3dRotationMatrix33	math3d.cpp	/^void m3dRotationMatrix33(M3DMatrix33d m, double angle, double x, double y, double z)$/;"	f
m3dRotationMatrix33	math3d.cpp	/^void m3dRotationMatrix33(M3DMatrix33f m, float angle, float x, float y, float z)$/;"	f
m3dRotationMatrix44	math3d.cpp	/^void m3dRotationMatrix44(M3DMatrix44d m, double angle, double x, double y, double z)$/;"	f
m3dRotationMatrix44	math3d.cpp	/^void m3dRotationMatrix44(M3DMatrix44f m, float angle, float x, float y, float z)$/;"	f
m3dScaleMatrix33	math3d.h	/^inline void m3dScaleMatrix33(M3DMatrix33d m, const M3DVector3d vScale)$/;"	f
m3dScaleMatrix33	math3d.h	/^inline void m3dScaleMatrix33(M3DMatrix33d m, double xScale, double yScale, double zScale)$/;"	f
m3dScaleMatrix33	math3d.h	/^inline void m3dScaleMatrix33(M3DMatrix33f m, const M3DVector3f vScale)$/;"	f
m3dScaleMatrix33	math3d.h	/^inline void m3dScaleMatrix33(M3DMatrix33f m, float xScale, float yScale, float zScale)$/;"	f
m3dScaleMatrix44	math3d.h	/^inline void m3dScaleMatrix44(M3DMatrix44d m, const M3DVector3d vScale)$/;"	f
m3dScaleMatrix44	math3d.h	/^inline void m3dScaleMatrix44(M3DMatrix44d m, double xScale, double yScale, double zScale)$/;"	f
m3dScaleMatrix44	math3d.h	/^inline void m3dScaleMatrix44(M3DMatrix44f m, const M3DVector3f vScale)$/;"	f
m3dScaleMatrix44	math3d.h	/^inline void m3dScaleMatrix44(M3DMatrix44f m, float xScale, float yScale, float zScale)$/;"	f
m3dScaleVector2	math3d.h	/^inline void m3dScaleVector2(M3DVector2d v, const double scale) $/;"	f
m3dScaleVector2	math3d.h	/^inline void m3dScaleVector2(M3DVector2f v, const float scale) $/;"	f
m3dScaleVector3	math3d.h	/^inline void m3dScaleVector3(M3DVector3d v, const double scale) $/;"	f
m3dScaleVector3	math3d.h	/^inline void m3dScaleVector3(M3DVector3f v, const float scale) $/;"	f
m3dScaleVector4	math3d.h	/^inline void m3dScaleVector4(M3DVector4d v, const double scale) $/;"	f
m3dScaleVector4	math3d.h	/^inline void m3dScaleVector4(M3DVector4f v, const float scale) $/;"	f
m3dSetMatrixColumn33	math3d.h	/^inline void m3dSetMatrixColumn33(M3DMatrix33d dst, const M3DVector3d src, const int column)$/;"	f
m3dSetMatrixColumn33	math3d.h	/^inline void m3dSetMatrixColumn33(M3DMatrix33f dst, const M3DVector3f src, const int column)$/;"	f
m3dSetMatrixColumn44	math3d.h	/^inline void m3dSetMatrixColumn44(M3DMatrix44d dst, const M3DVector4d src, const int column)$/;"	f
m3dSetMatrixColumn44	math3d.h	/^inline void m3dSetMatrixColumn44(M3DMatrix44f dst, const M3DVector4f src, const int column)$/;"	f
m3dSetVectorW	math3d.h	141;"	d
m3dSetVectorX	math3d.h	138;"	d
m3dSetVectorY	math3d.h	139;"	d
m3dSetVectorZ	math3d.h	140;"	d
m3dSmoothStep	math3d.cpp	/^double m3dSmoothStep(const double edge1, const double edge2, const double x)$/;"	f
m3dSmoothStep	math3d.cpp	/^float m3dSmoothStep(const float edge1, const float edge2, const float x)$/;"	f
m3dSubtractVectors2	math3d.h	/^inline void m3dSubtractVectors2(M3DVector2d r, const M3DVector2d a, const M3DVector2d b)$/;"	f
m3dSubtractVectors2	math3d.h	/^inline void m3dSubtractVectors2(M3DVector2f r, const M3DVector2f a, const M3DVector2f b)$/;"	f
m3dSubtractVectors3	math3d.h	/^inline void m3dSubtractVectors3(M3DVector3d r, const M3DVector3d a, const M3DVector3d b)$/;"	f
m3dSubtractVectors3	math3d.h	/^inline void m3dSubtractVectors3(M3DVector3f r, const M3DVector3f a, const M3DVector3f b)$/;"	f
m3dSubtractVectors4	math3d.h	/^inline void m3dSubtractVectors4(M3DVector4d r, const M3DVector4d a, const M3DVector4d b)$/;"	f
m3dSubtractVectors4	math3d.h	/^inline void m3dSubtractVectors4(M3DVector4f r, const M3DVector4f a, const M3DVector4f b)$/;"	f
m3dTransformVector3	math3d.h	/^__inline void m3dTransformVector3(M3DVector3d vOut, const M3DVector3d v, const M3DMatrix44d m)$/;"	f
m3dTransformVector3	math3d.h	/^__inline void m3dTransformVector3(M3DVector3f vOut, const M3DVector3f v, const M3DMatrix44f m)$/;"	f
m3dTransformVector4	math3d.h	/^__inline void m3dTransformVector4(M3DVector4d vOut, const M3DVector4d v, const M3DMatrix44d m)$/;"	f
m3dTransformVector4	math3d.h	/^__inline void m3dTransformVector4(M3DVector4f vOut, const M3DVector4f v, const M3DMatrix44f m)$/;"	f
m3dTranslationMatrix44	math3d.h	/^inline void m3dTranslationMatrix44(M3DMatrix44d m, double x, double y, double z)$/;"	f
m3dTranslationMatrix44	math3d.h	/^inline void m3dTranslationMatrix44(M3DMatrix44f m, float x, float y, float z)$/;"	f
main	fulcrum.cpp	/^int main( int argc, char* args[] ) {$/;"	f
main	testshadermanage.cpp	/^int main(int argc, char** argv) {$/;"	f
material_diffuse_color	_shader_manager.hpp	/^	       material_diffuse_color,$/;"	m	class:_shader_manager
material_specular_color	_shader_manager.hpp	/^	       material_specular_color;$/;"	m	class:_shader_manager
message	_controller_base.hpp	/^	void message ( const int msg ){ control_message con_msg( msg, 0 );_message.push_back( con_msg ); }$/;"	f	class:_controller_base
message	_controller_base.hpp	/^	void message ( const int msg, const int msg_info ){ control_message con_msg( msg, msg_info );_message.push_back( con_msg ); }$/;"	f	class:_controller_base
message_clear	_controller_base.hpp	/^	void message_clear ( void ){ _message.clear(); }$/;"	f	class:_controller_base
move_and_turn	_object_base.cpp	/^void _object_base::move_and_turn ( const std::vector<control_message>& msg ) {$/;"	f	class:_object_base
move_camera	_controller_base.cpp	/^void _controller_base::move_camera ( const glm::vec3& move_to ) {$/;"	f	class:_controller_base
move_object	_controller_base.cpp	/^void _controller_base::move_object ( const int move ) {$/;"	f	class:_controller_base
move_to	_model_manager.hpp	/^	void move_to ( const int& side ) {$/;"	f	class:cube
msg	_object_base.hpp	/^	int msg;$/;"	m	struct:control_message
msg_info	_object_base.hpp	/^	int msg_info;$/;"	m	struct:control_message
multiply_matrix_follow_in_world	_object_base.cpp	/^void _object_base::multiply_matrix_follow_in_world ( const glm::mat4& matrix ) {$/;"	f	class:_object_base
multiply_matrix_in_world	_object_base.cpp	/^void _object_base::multiply_matrix_in_world ( const glm::mat4& matrix ) {$/;"	f	class:_object_base
normal_transforms	_shader_manager.hpp	/^	       normal_transforms,$/;"	m	class:_shader_manager
object_transforms	_shader_manager.hpp	/^	GLuint object_transforms,$/;"	m	class:_shader_manager
operator =	_asset_manager.hpp	/^	triangle& operator= ( const triangle& right ) {$/;"	f	struct:triangle
override	_camera_base.hpp	/^	void follow ( const _object_base* be_followed_object, bool only_position = false ) override;$/;"	m	class:_camera_base
override	_camera_base.hpp	/^	void rotate ( const float& angle, const glm::vec3& rotate_axis ) override;$/;"	m	class:_camera_base
override	_camera_base.hpp	/^	void translate ( const glm::vec3& direction ) override;$/;"	m	class:_camera_base
override	_camera_base.hpp	/^	void update (void) override;$/;"	m	class:_camera_base
override	fulcrum.cpp	/^	void edit_scene (void) override;$/;"	m	class:game_scene	file:
override	fulcrum.cpp	/^	void update (void) override;$/;"	m	class:game_camera	file:
perspective	_camera_base.cpp	/^void _camera_base::perspective ( float fovy, float aspect, float zNear, float zFar ) {$/;"	f	class:_camera_base
perspective_transforms	_shader_manager.hpp	/^	       perspective_transforms,$/;"	m	class:_shader_manager
program	ShaderManage.hpp	/^	GLuint program;$/;"	m	class:ShaderManage
read_dae	_asset_manager.cpp	/^void _asset_manager::read_dae ( const std::string& file_name ) {$/;"	f	class:_asset_manager
read_file	_asset_manager.cpp	/^void _asset_manager::read_file ( const std::string& file_name, const unsigned int& format ) {$/;"	f	class:_asset_manager
realse_camera	_object_base.hpp	/^	inline void realse_camera (void) { _is_catch_camera = false; }$/;"	f	class:_object_base
realse_controller	_object_base.hpp	/^	inline void realse_controller (void) { _is_be_controlled = false; }$/;"	f	class:_object_base
recursiveProcess	_asset_manager.cpp	/^void _asset_manager::recursiveProcess( const aiNode* node, const aiScene* scene ) {$/;"	f	class:_asset_manager
recursiveProcess	_model_manager.cpp	/^void _model_manager::recursiveProcess( aiNode* node, const aiScene* scene ) {$/;"	f	class:_model_manager
render_scene	_scene_base.cpp	/^void _scene_base::render_scene (void) {$/;"	f	class:_scene_base
rotate	_camera_base.cpp	/^void _camera_base::rotate ( const float& angle, const glm::vec3& rotate_axis ) {$/;"	f	class:_camera_base
rotate	_object_base.cpp	/^void _object_base::rotate ( const float& angle, const glm::vec3& rotate_axis ) {$/;"	f	class:_object_base
scene_out_test	fulcrum.cpp	/^std::shared_ptr<game_scene> scene_out_test;$/;"	v
set_ID	_object_base.hpp	/^	inline void set_ID ( const unsigned int ID ) { _ID = ID; }$/;"	f	class:_object_base
set_ambient_color	_scene_base.cpp	/^void _scene_base::set_ambient_color ( const glm::vec4 color ) {$/;"	f	class:_scene_base
set_diffuse_color	_light_base.cpp	/^void _light_base::set_diffuse_color ( glm::vec3 color ) {$/;"	f	class:_light_base
set_material_diffuse_color	_object_base.hpp	/^	inline void set_material_diffuse_color ( const glm::vec4& color ) { _material_diffuse_color = color; }$/;"	f	class:_object_base
set_material_specular_color	_object_base.hpp	/^	inline void set_material_specular_color ( const glm::vec4& color ) { _material_specular_color = color; }$/;"	f	class:_object_base
set_matrix_in_world	_object_base.hpp	/^	inline void set_matrix_in_world ( const glm::mat4& matrix ) { _matrix_in_world = matrix; }$/;"	f	class:_object_base
set_position_in_world	_object_base.cpp	/^void _object_base::set_position_in_world ( const glm::vec3& position ) {$/;"	f	class:_object_base
set_specular_color	_light_base.cpp	/^void _light_base::set_specular_color ( glm::vec3 color ) {$/;"	f	class:_light_base
set_uniform_location	_shader_manager.cpp	/^void _shader_manager::set_uniform_location (const std::string names\/**the max in string**\/) {$/;"	f	class:_shader_manager
shader	ShaderManage.hpp	/^	GLuint shader;$/;"	m	class:ShaderManage
shader	testshadermanage.cpp	/^GLuint shader;$/;"	v
shaderList	ShaderManage.hpp	/^	std::vector<GLuint> shaderList;$/;"	m	class:ShaderManage
shader_load	_scene_base.cpp	/^void _scene_base::shader_load ( const std::string shader_file_names, const unsigned int shader_name ) {$/;"	f	class:_scene_base
side_length	_model_manager.hpp	/^		float side_length;$/;"	m	struct:cube::cube_info
specular_color	_shader_manager.hpp	/^	       specular_color,$/;"	m	class:_shader_manager
start_vertex	_model_manager.hpp	/^		glm::vec3 start_vertex;$/;"	m	struct:cube::cube_info
store_model_data	_asset_manager.cpp	/^bool _asset_manager::store_model_data ( const std::string& file_name ) {$/;"	f	class:_asset_manager
translate	_camera_base.cpp	/^void _camera_base::translate ( const glm::vec3& direction) {$/;"	f	class:_camera_base
translate	_object_base.cpp	/^void _object_base::translate ( const glm::vec3& direction ) {$/;"	f	class:_object_base
triangle	_asset_manager.hpp	/^	triangle ( const glm::vec3& x_, const glm::vec3& y_, const glm::vec3& z_ ) : x(x_), y(y_), z(z_) {}$/;"	f	struct:triangle
triangle	_asset_manager.hpp	/^	triangle ( const triangle& right) : x(right.x), y(right.y), z(right.z) {}$/;"	f	struct:triangle
triangle	_asset_manager.hpp	/^	triangle (void) : x(), y(), z() {}$/;"	f	struct:triangle
triangle	_asset_manager.hpp	/^struct triangle {$/;"	s
turn_camera	_controller_base.cpp	/^void _controller_base::turn_camera ( const float angle, const glm::vec3& aix ) {$/;"	f	class:_controller_base
uniform_name	_shader_manager.hpp	/^	inline GLuint uniform_name ( const std::string uniformNamesInShader ) const { return _uniformNames.at( uniformNamesInShader.c_str() ); }$/;"	f	class:_shader_manager
update	_camera_base.cpp	/^void _camera_base::update (void) {}$/;"	f	class:_camera_base
update	_object_base.cpp	/^void _object_base::update (void) {$/;"	f	class:_object_base
update	fulcrum.cpp	/^void game_camera::update (void) {$/;"	f	class:game_camera
update_camera_matrix	_camera_base.cpp	/^void _camera_base::update_camera_matrix ( const glm::mat4& update_matrix ) {$/;"	f	class:_camera_base
update_camera_matrix_follow_in_world_gl_uniform	_camera_base.cpp	/^void _camera_base::update_camera_matrix_follow_in_world_gl_uniform ( const _shader_manager& be_using_shader ) {$/;"	f	class:_camera_base
update_camera_matrix_from_object	_camera_base.cpp	/^void _camera_base::update_camera_matrix_from_object ( const glm::mat4& object_matrix ) {$/;"	f	class:_camera_base
update_camera_perspective_matrix_gl_uniform	_camera_base.cpp	/^void _camera_base::update_camera_perspective_matrix_gl_uniform ( const _shader_manager& be_using_shader ) {$/;"	f	class:_camera_base
update_gl_uniform	_object_base.cpp	/^void _object_base::update_gl_uniform ( const _shader_manager& be_using_shader ) {$/;"	f	class:_object_base
update_lights	_light_base_set.cpp	/^void _light_base_set::update_lights (void) {$/;"	f	class:_light_base_set
update_lights_data	_light_base_set.cpp	/^void _light_base_set::update_lights_data ( const glm::mat4& update_matrix ) {$/;"	f	class:_light_base_set
update_lights_data_to_gl_uniform	_light_base_set.cpp	/^void _light_base_set::update_lights_data_to_gl_uniform ( const _shader_manager& be_using_shader ) {$/;"	f	class:_light_base_set
update_matrix_catch_camera_in_world	_object_base.cpp	/^void _object_base::update_matrix_catch_camera_in_world ( const glm::mat4& update_matrix ) {$/;"	f	class:_object_base
update_matrix_in_camera_world	_object_base.cpp	/^void _object_base::update_matrix_in_camera_world ( const glm::mat4& update_matrix ) {$/;"	f	class:_object_base
update_scene	_scene_base.cpp	/^void _scene_base::update_scene (void) {$/;"	f	class:_scene_base
x	_asset_manager.hpp	/^	glm::vec3 x, y, z;$/;"	m	struct:triangle
y	_asset_manager.hpp	/^	glm::vec3 x, y, z;$/;"	m	struct:triangle
z	_asset_manager.hpp	/^	glm::vec3 x, y, z;$/;"	m	struct:triangle
~ShaderManage	ShaderManage.cpp	/^ShaderManage::~ShaderManage(void)$/;"	f	class:ShaderManage
~_asset_manager	_asset_manager.cpp	/^_asset_manager::~_asset_manager(void) {}$/;"	f	class:_asset_manager
~_camera_base	_camera_base.cpp	/^_camera_base::~_camera_base (void) { }$/;"	f	class:_camera_base
~_controller_base	_controller_base.cpp	/^_controller_base::~_controller_base (void) {}$/;"	f	class:_controller_base
~_light_base	_light_base.cpp	/^_light_base::~_light_base (void) {}$/;"	f	class:_light_base
~_light_base_set	_light_base_set.cpp	/^_light_base_set::~_light_base_set (void) {$/;"	f	class:_light_base_set
~_model_manager	_model_manager.cpp	/^_model_manager::~_model_manager (void) {$/;"	f	class:_model_manager
~_object_base	_object_base.cpp	/^_object_base::~_object_base (void) {$/;"	f	class:_object_base
~_scene_base	_scene_base.cpp	/^_scene_base::~_scene_base (void) {$/;"	f	class:_scene_base
~_shader_manager	_shader_manager.cpp	/^_shader_manager::~_shader_manager (void) { }$/;"	f	class:_shader_manager
~game_camera	fulcrum.cpp	/^game_camera::~game_camera (void) {}$/;"	f	class:game_camera
~game_object	fulcrum.cpp	/^game_object::~game_object (void) {}$/;"	f	class:game_object
~game_scene	fulcrum.cpp	/^game_scene::~game_scene (void) {}$/;"	f	class:game_scene
